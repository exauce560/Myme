<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Chat - Myme</title>
    <link href="https://fonts.googleapis.com/css2?family=Permanent+Marker&family=Rock+Salt&family=Caveat:wght@400;700&family=Shadows+Into+Light&family=Gochi+Hand&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #ffffff; --text: #1c1e21; --gray: #65676b; --gra: #4c79ff;
            --myme-blue: #0866ff; --hover-bg: #f2f2f2; --myme-blu: linear-gradient(135deg, #0866ff, #0549b8);
            --card-border: #f0f2f5; --msg-me: #0866ff; --msg-them: #e4e6eb; --myme-green: #29bd49;
            --header-bg: #ffffff; --myme-bl: #1e3cd0;
            --app-font-size: 16px;
            --app-font-family: 'Segoe UI', sans-serif;
            --app-radius: 18px;
            --app-spacing: normal;
        }
        body.dark-mode {
            --bg: #111111; --text: #e4e6eb; --gray: #b0b3b8;
            --hover-bg: #242526; --card-border: #2f3031; --msg-them: #303030;
            --header-bg: #111111;
        }
        body {
            background-color: var(--bg);
            background: transparent;
            color: var(--text);
            font-family: var(--app-font-family);
            font-size: var(--app-font-size);
            letter-spacing: var(--app-spacing);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            transition: 0.3s;
        }

        header { padding: 10px 15px; display: flex; align-items: center; border-bottom: 1px solid var(--card-border); background: var(--header-bg); position: sticky; top: 0; z-index: 100; height: 65px; box-sizing: border-box;}
        .back-btn { background: none; border: none; cursor: pointer; color: var(--text); padding: 8px; display: flex; align-items: center; border-radius: 50%; transition: 0.2s; }
        .back-btn:hover { background: var(--hover-bg); }
        .user-profile { flex: 1; display: flex; align-items: center; margin-left: 5px; cursor: pointer; }
        .avatar-chat { width: 42px; height: 42px; border-radius: 50%; object-fit: cover; background: #eee; }
        .user-status { margin-left: 10px; display: flex; flex-direction: column; }
        .status-dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 5px; }
        .online { background: #29bd49; }
        .offline { background: #8e8e8e; }

        #custom-context-menu {
            position: fixed; display: none; background: var(--header-bg);
            border: 1px solid var(--card-border); box-shadow: 0 4px 12px rgba(0,0,0,0.25);
            border-radius: 12px; z-index: 3000; padding: 6px; min-width: 150px;
        }
        .context-item {
            padding: 12px 15px; cursor: pointer; color: #ff4d4d; font-weight: bold;
            font-size: 14px; border-radius: 8px; display: flex; align-items: center;
            gap: 10px; transition: background 0.2s;
        }
        .context-item:hover { background: var(--hover-bg); }

        #chat-container { flex: 1; position: relative; overflow: hidden; display: flex; flex-direction: column; background: transparent; margin-bottom: 0;}
        #chat-bg { position: fixed; top: 0; height: 100vh; left: 0; width: 100vw; background-size: cover; background-position: center; z-index: -1; }
        #bg-overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: black; z-index: 2; pointer-events: none; opacity: 0; }
        #chat-window { flex:1; position: relative; width: 100%; height: 100%; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 8px; z-index: 3; box-sizing: border-box; scroll-behavior: smooth; background: transparent;}

        .msg-wrapper { display: flex; flex-direction: column; margin-bottom: 2px; -webkit-tap-highlight-color: transparent; }
        .msg-bubble {
            max-width: 75%; padding: 10px 14px; border-radius: var(--app-radius);
            font-size: 14px; position: relative; box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            word-wrap: break-word; cursor: pointer; font-family: inherit;
        }
        .msg-wrapper.me .msg-bubble { align-self: flex-end; background: var(--myme-blu); color: white; border-bottom-right-radius: 4px; }
        .msg-wrapper.them .msg-bubble { align-self: flex-start; background: var(--msg-them); color: var(--text); border-bottom-left-radius: 4px; }

        .msg-img { max-width: 75%; border-radius: 12px; display: block; margin-top: 5px; cursor: zoom-in; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        .me .msg-img { align-self: flex-end; }
        .them .msg-img { align-self: flex-start; }

        .msg-info { font-size: 10px; margin-top: 2px; opacity: 0.7; }
        .me .msg-info { align-self: flex-end; }
        .them .msg-info { align-self: flex-start; }

        .vocal-bubble { display: flex; align-items: center; gap: 10px; padding: 10px; border-radius: 18px; background: var(--hover-bg); min-width: 160px; }
        .me .vocal-bubble { background: var(--myme-blue); color: white; align-self: flex-end; }
        .them .vocal-bubble { align-self: flex-start; }
        .vocal-bubble button { background: white; border: none; border-radius: 50%; width: 30px; height: 30px; cursor: pointer; color: var(--myme-bl); font-weight: bold; }

        .input-area { padding: 10px 15px; display: flex; align-items: center; gap: 10px; background: transparent; border: none; z-index: 10; margin-bottom: 10px;}
        .message-input { flex: 1; background: var(--hover-bg); backdrop-filter: blur(10px); border: 1px solid #333; padding: 12px 18px; border-radius: 25px; color: var(--text); outline: none; font-size: 15px; font-family: inherit; }
        .record-btn { background: none; border: none; cursor: pointer; color: #4c79ff; padding: 5px; display: flex; align-items: center; }
        .record-btn.recording { color: #b1ff4c; animation: pulse 1s infinite; }
        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.1); } 100% { transform: scale(1); } }
        #recording-label { display: none; color: #b1ff4c; font-weight: bold; flex: 1; }

        #contact-profile { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: var(--bg); z-index: 2000; display: none; flex-direction: column; align-items: center; box-sizing: border-box; overflow-y: auto; padding-bottom: 40px;}
        .profile-banner { width: 100%; height: 120px; background: linear-gradient(45deg, var(--myme-blue), #5094ff); position: relative; flex-shrink: 0; }
        .profile-pic-large { width: 150px; height: 150px; border-radius: 50%; object-fit: cover; margin-top: -75px; border: 6px solid var(--bg); position: relative; z-index: 2001; box-shadow: 0 4px 15px rgba(0,0,0,0.15); flex-shrink: 0; }
        .profile-actions { display: flex; gap: 20px; margin: 20px 0; }
        .p-action-btn { background: var(--hover-bg); border: none; padding: 12px; border-radius: 50%; cursor: pointer; color: var(--myme-blue); transition: 0.3s; }
        .p-action-btn:hover { background: var(--myme-blue); color: white; transform: scale(1.1); }

        .profile-info-section { width: 90%; text-align: center; }
        .phone-link { display: flex; align-items: center; justify-content: center; gap: 10px; font-size: 18px; font-weight: bold; color: var(--myme-green); text-decoration: none; margin: 10px 0; background: var(--hover-bg); padding: 10px; border-radius: 12px; }

        .media-gallery-container { width: 100%; padding: 0 15px; box-sizing: border-box; margin-top: 30px; }
        .gallery-title { font-weight: bold; font-size: 16px; margin-bottom: 15px; display: flex; justify-content: space-between; }
        .media-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 5px; }
        .media-item { aspect-ratio: 1; background: var(--hover-bg); border-radius: 8px; overflow: hidden; cursor: pointer; }
        .media-item img { width: 100%; height: 100%; object-fit: cover; }
        .empty-gallery { color: var(--gray); text-align: center; font-style: italic; font-size: 13px; grid-column: span 3; padding: 20px; }

        .block-btn { margin-top: 40px; color: #ff4d4d; background: #ff4d4d15; border: none; padding: 15px 30px; border-radius: 25px; font-weight: bold; cursor: pointer; transition: 0.3s; width: 80%; }
        .block-btn:hover { background: #ff4d4d; color: white; }

        #chat-menu { position: fixed; top: 60px; right: 15px; background: var(--header-bg); border: 1px solid var(--card-border); border-radius: 12px; display: none; flex-direction: column; z-index: 1000; box-shadow: 0 8px 24px rgba(0,0,0,0.2); width: 220px; }
        .menu-item { padding: 12px 15px; border: none; background: none; color: var(--text); cursor: pointer; display: flex; align-items: center; gap: 12px; font-size: 14px; text-align: left; width: 100%; font-family: inherit; }
        .menu-item.danger { color: #ff9500; font-weight: bold; }
        .reply-quote {
            background: rgba(0, 0, 0, 0.08);
            border-left: 3px solid var(--myme-blue);
            padding: 5px 8px;
            margin-bottom: 6px;
            border-radius: 4px;
            font-size: 11px;
            color: inherit;
            opacity: 0.9;
            display: block;
            max-width: 100%;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

/* Ajustement pour le mode sombre */
        body.dark-mode .reply-quote {
            background: rgba(255, 255, 255, 0.1);
        }

/* Correction du menu contextuel pour qu'il ne soit pas QUE rouge */
        .context-item {
            color: var(--text); /* Par d√©faut texte normal */
        }
        .context-item#delete-action-btn {
            color: #ff4d4d; /* Uniquement supprimer en rouge */
        }
        #toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(50, 50, 50, 0.95);
            color: white;
            padding: 12px 24px;
            border-radius: 50px;
            font-size: 14px;
            display: none;
            z-index: 3000; /* Assurez-vous qu'il est au-dessus du profil */
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            animation: fadeInOut 0.3s;
        }
        .typing-indicator {
            display: inline-flex;
            align-items: center;
            margin-left: 5px;
        }

        .typing-indicator span {
            height: 4px;
            width: 4px;
            float: left;
            margin: 0 1px;
            background-color: #0866ff;
            display: block;
            border-radius: 50%;
            opacity: 0.4;
            animation: typing 1s infinite;
        }

        .typing-indicator span:nth-child(1) { animation-delay: 0s; }
        .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
        .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

        @keyframes typing {
            0% { transform: translateY(0px); opacity: 0.4; }
            50% { transform: translateY(-4px); opacity: 1; }
            100% { transform: translateY(0px); opacity: 0.4; }
        }

        @keyframes fadeInOut {
            from { opacity: 0; bottom: 80px; }
            to { opacity: 1; bottom: 100px; }
        }
        /* Style des coches */
        .status-pending { color: #aaa; } /* Gris : en attente */
        .status-sent { color: #0866ff; }    /* Bleu/Noir : envoy√© */
        .status-read { color: #25D366; font-weight: bold; } /* Vert : lu */
        .msg-wrapper.me.pending {
            opacity: 0.7; /* Le message est l√©g√®rement transparent tant qu'il est offline */
        }

        .msg-info {
            display: flex;
            justify-content: flex-end;
            gap: 4px;
            margin-top: 2px;
        }
        /* Mode Sombre : Les couleurs s'inversent via les variables */
        body.dark-mode {
            --bg: #111111;
            --text: #e4e6eb;
            --gray: #b0b3b8;
            --hover-bg: #242526;
            --card-border: #2f3031;
            --msg-them: #303030; /* Bulle du contact en sombre */
            --header-bg: #111111;
        }

        /* Application sur les bulles */
        .msg-wrapper.them .msg-bubble {
            background: var(--msg-them);
            color: var(--text);
        }
        /* Cache le bouton retour si on est dans l'iframe desktop */
        @media screen and (min-width: 900px) {
            .back-button { display: none; }
        }
    </style>
    <link rel="apple-touch-icon" sizes="57x57" href="apple-icon-57x57.png">
<link rel="apple-touch-icon" sizes="60x60" href="apple-icon-60x60.png">
<link rel="apple-touch-icon" sizes="72x72" href="apple-icon-72x72.png">
<link rel="apple-touch-icon" sizes="76x76" href="apple-icon-76x76.png">
<link rel="apple-touch-icon" sizes="114x114" href="apple-icon-114x114.png">
<link rel="apple-touch-icon" sizes="120x120" href="apple-icon-120x120.png">
<link rel="apple-touch-icon" sizes="144x144" href="apple-icon-144x144.png">
<link rel="apple-touch-icon" sizes="152x152" href="apple-icon-152x152.png">
<link rel="apple-touch-icon" sizes="180x180" href="apple-icon-180x180.png">

<link rel="icon" type="image/png" sizes="192x192" href="android-icon-192x192.png">

<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="icon" type="image/png" sizes="96x96" href="favicon-96x96.png">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">

<link rel="manifest" href="manifest.json">
<meta name="msapplication-TileColor" content="#ffffff">
<meta name="msapplication-TileImage" content="ms-icon-144x144.png">
<meta name="theme-color" content="#ffffff">
</head>
<body onclick="closeAllMenus()">
    <audio id="send-sound" src="https://assets.mixkit.co/active_storage/sfx/2358/2358-preview.mp3" preload="auto"></audio>
    <header>
        <button class="back-btn" onclick="window.history.back()">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M15 18l-6-6 6-6"/></svg>
        </button>
        <div class="user-profile" onclick="showProfile(event)">
            <img src="" id="target-avatar" class="avatar-chat">
            <div class="user-status">
                <strong id="target-name">Chargement...</strong>
                <span id="status-row" style="font-size: 11px; display: flex; align-items: center;">
                    <span id="presence-dot" class="status-dot offline"></span>
                    <span id="presence-text">--</span>
                    <div id="typing-dots" class="typing-indicator" style="display: none; margin-left: 5px;">
                        <span></span><span></span><span></span>
                    </div>
                </span>
            </div>
        </div>
        <button class="back-btn" onclick="toggleMenu(event)">
            <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor"><path d="M12 8c1.1 0 2-.9 2-2s-.9-2-2-2-2 .9-2 2 .9 2 2 2zm0 2c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2zm0 6c-1.1 0-2 .9-2 2s.9 2 2 2 2-.9 2-2-.9-2-2-2z"/></svg>
        </button>
    </header>

    <div id="chat-menu" onclick="event.stopPropagation()">
        <button class="menu-item" onclick="showProfile(event)" data-lang="see-profil">üë§ Voir son profil</button>
        <label class="menu-item">
            <span data-lang="font">Fond d'√©cran</span>
            <input type="file" hidden accept="image/*" id="wall-input" onchange="changeWallpaper(this)">
        </label>
        <button class="menu-item danger" onclick="clearFullChat()" data-lang="delete-chat">üóëÔ∏è Vider la discussion</button>
        <div style="padding: 10px 15px; border-top: 1px solid var(--card-border);">
            <small style="color: var(--gray);" data-lang="lum">Luminosit√© fond</small>
            <input type="range" id="lum-range" min="0" max="0.8" step="0.1" value="0" style="width: 100%;" oninput="changeBrightness(this.value)">
        </div>
    </div>

    <div id="contact-profile">
        <div class="profile-banner">
            <button class="back-btn" style="color: white; margin: 10px;" onclick="hideProfile()">
                <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><path d="M15 18l-6-6 6-6"/></svg>
            </button>
        </div>
        <img src="" id="profile-img-full" class="profile-pic-large">
        <div class="profile-info-section">
            <h2 id="profile-name-full" style="margin-bottom: 5px;">...</h2>
            <p id="profile-status-full" style="color: var(--gray); margin-top: 0;" data-lang="contact-label">Contact</p>
            <a href="#" id="profile-phone-link" class="phone-link">
                <svg width="20" height="20" fill="currentColor" viewBox="0 0 24 24"><path d="M6.62 10.79c1.44 2.83 3.76 5.14 6.59 6.59l2.2-2.2c.28-.28.67-.36 1.02-.24 1.12.37 2.33.57 3.57.57.55 0 1 .45 1 1V20c0 .55-.45 1-1 1-9.39 0-17-7.61-17-17 0-.55.45-1 1-1h3.5c.55 0 1 .45 1 1 0 1.25.2 2.45.57 3.57.11.35.03.74-.25 1.02l-2.2 2.2z"/></svg>
                <span id="profile-phone-full">...</span>
            </a>
            <div class="profile-actions">
                <button class="p-action-btn" onclick="showToastByLang('call-unavailable')">üìπ</button>
                <button class="p-action-btn" onclick="showToastByLang('search-unavailable')">üîç</button>
                <button class="p-action-btn"  onclick="showToastByLang('notif-muted')">üîî</button>
            </div>
            <div class="media-gallery-container">
                <div class="gallery-title">
                    <span data-lang="shared-media">M√©dias partag√©s</span>
                    <span id="media-count-badge" style="color: var(--gray); font-weight: normal; font-size: 13px;">0 media</span>
                </div>
                <div class="media-grid" id="profile-media-grid">
                    <div class="empty-gallery" data-lang="media">Aucun m√©dia partag√©.</div>
                </div>
            </div>
            <button class="block-btn" data-lang="block-users" id="block-action-btn">Bloquer ce contact</button>
        </div>
    </div>

    <div id="custom-context-menu">
        <div class="context-item" style="color: var(--text);" onclick="prepareReply()">
            <span>‚Ü©Ô∏è</span> <span data-lang="reply">R√©pondre</span>
        </div>
        <div class="context-item" id="delete-action-btn" onclick="deleteMessageSync()">
            <span>üóëÔ∏è</span> <span data-lang="delete">Supprimer</span>
        </div>
    </div>

    <div id="chat-container">
        <div id="chat-bg"></div>
        <div id="bg-overlay"></div>
        <div id="chat-window"></div>
    </div>
    <div id="reply-preview" style="display:none; background:#f0f0f0; padding:10px; border-left:4px solid #0866ff; position:relative;">
        <span id="reply-text" style="font-size:12px; color:#555;"></span>
        <button onclick="cancelReply()" style="position:absolute; right:10px; top:5px; border:none; background:none; cursor:pointer;">‚úï</button>
    </div>

    <div class="input-area" id="input-bar">
        <label class="record-btn">
            <svg width="26" height="26" viewBox="0 0 24 24" fill="currentColor"><path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/></svg>
            <input type="file" id="img-send" hidden accept="image/*" onchange="sendImage(this)">
        </label>
        <button id="voice-btn" class="record-btn" style="touch-action: none;">
            <svg width="26" height="26" viewBox="0 0 24 24" fill="currentColor"><path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/><path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/></svg>
        </button>
        <div id="recording-label">00:00</div>
        <input type="text" id="msg-input" class="message-input" data-lang="placeholder-msg" placeholder="Message...">
        <button id="send-btn" class="back-btn" style="color: var(--myme-blue); display: none; flex-shrink: 0;" onclick="sendMessage()">
            <svg width="28" height="28" viewBox="0 0 24 24" fill="currentColor"><path d="M2.01 21L23 12 2.01 3 2 10l15 2-15 2z"/></svg>
        </button>
    </div>

    <div id="confirm-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.6); z-index:9999; align-items:center; justify-content:center; backdrop-filter: blur(4px);">
        <div style="background:var(--header-bg); padding:24px; border-radius:var(--app-radius); width:85%; max-width:320px; text-align:center; box-shadow:0 20px 40px rgba(0,0,0,0.4); border:1px solid var(--card-border);">
            <div style="font-size: 40px; margin-bottom: 10px;">üóëÔ∏è</div>
            <h3 style="margin:0 0 10px 0; color:var(--text);" data-lang="confirm-title">Vider la discussion ?</h3>
            <p style="color:var(--gray); font-size:14px; margin-bottom:20px;" data-lang="confirm-text">Cette action est irr√©versible. Les messages disparaitront pour toujours.</p>

            <div style="display:flex; gap:12px;">
                <button onclick="closeConfirmModal()" style="flex:1; padding:12px; border:none; border-radius:12px; background:var(--hover-bg); color:var(--text); font-weight:600; cursor:pointer;" data-lang="cancel">Annuler</button>
                <button onclick="executeClearChat()" style="flex:1; padding:12px; border:none; border-radius:12px; background:#ff4d4d; color:white; font-weight:bold; cursor:pointer;" data-lang="delete-btn">Vider</button>
            </div>
        </div>
    </div>

    <div id="toast"></div>
<script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
    import { 
        getFirestore, collection, addDoc, onSnapshot, query, orderBy, 
        doc, deleteDoc, serverTimestamp, updateDoc, getDocs, getDoc, 
        where, arrayUnion, setDoc 
    } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";
    import { getAuth, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
    import { onDisconnect, ref, set, onValue } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js";
// Note : Le statut de pr√©sence utilise souvent Realtime Database car c'est plus rapide et moins cher que Firestore pour √ßa.



    const firebaseConfig = {
        apiKey: "AIzaSyA3YTGXBA9Cf9QNaGau0PCBgyuGSJv5pi0",
        authDomain: "myme-31f3c.firebaseapp.com",
        projectId: "myme-31f3c",
        storageBucket: "myme-31f3c.firebasestorage.app",
        messagingSenderId: "598768810366",
        appId: "1:598768810366:web:b401c77010102e8988db2f"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    const auth = getAuth(app);
    const targetUid = new URLSearchParams(window.location.search).get('uid');
    const STORAGE_KEY = `chat_history_${targetUid}`;

    let isRendering = false;
    let selectedMsgId = null;
    let recInterval;
    let replyingTo = null;
    let typingTimeout = null;
    let mediaStream = null;
    let myBlockedList = [];

    async function clearBadgeOnEntry() {
        const user = auth.currentUser;
        if (!user || !targetUid) return
        const myUid = user.uid;

        try {
            const chatId = myUid < targetUid ? myUid + "_" + targetUid : targetUid + "_" + myUid;
            const msgRef = collection(db, "chats", chatId, "messages");

            // On cible uniquement les messages que J'AI RE√áUS et qui sont NON LUS
            const q = query(msgRef,
                where("receiverId", "==", myUid),
                where("read", "==", false)
            );

            const snap = await getDocs(q);

            // Utilise Promise.all pour aller plus vite si tu as beaucoup de messages
            const updates = snap.docs.map(m => updateDoc(m.ref, { read: true }));
            await Promise.all(updates);

            console.log("Badges nettoy√©s !");
        } catch (e) {
            console.error("Erreur clearBadge:", e);
        }
    }

    async function requestAndroidPermissions() {
        // On v√©rifie d'abord si l'objet Capacitor existe ET si on est sur mobile
        // window.Capacitor && ... √©vite l'erreur "ReferenceError"
        if (window.Capacitor && window.Capacitor.isNativePlatform()) {
            try {
                // 1. Demande pour le Filesystem
                await Filesystem.requestPermissions();

                // 2. Demande pour les M√©dias
                const { Media } = Capacitor.Plugins;
                if (Media) {
                    await Media.requestPermissions();
                }

                // 3. Demande pour le micro (Fonctionne aussi sur certains navigateurs PC)
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    await navigator.mediaDevices.getUserMedia({ audio: true });
                }

            } catch (e) {
                console.log("Erreur ou refus des permissions", e);
            }
        } else {
            // Optionnel : ce qui se passe sur PC
            console.log("Mode Web : Permissions natives ignor√©es.");
        }
    }

    // Lancement de la fonction
    requestAndroidPermissions();
    // VERSION SIMPLE (Firestore uniquement)
    function setPresence(uid) {
        const userRef = doc(db, "users", uid);

        // 1. On passe "En ligne" d√®s qu'on charge la page
        updateDoc(userRef, { isOnline: true });

        // 2. Probl√®me : Comment passer "Hors ligne" quand on ferme l'appli ?
        // Sur le Web, on utilise cet √©v√©nement :
        window.addEventListener('beforeunload', () => {
            updateDoc(userRef, { isOnline: false });
        });
    }
    // Appel√© quand on clique sur "R√©pondre" dans le menu
    window.prepareReply = () => {
        const history = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
        const msg = history.find(m => m.id === selectedMsgId);

        if (msg) {
            replyingTo = {
                id: msg.id,
                senderId: msg.senderId,
                // Si c'est une image/vocal, on met un texte de remplacement pour √©viter le "undefined"
                text: msg.type === 'image' ? "üì∑ Photo" : (msg.type === 'voice' ? "üé§ Vocal" : (msg.text || "Message"))
            };
            const preview = document.getElementById('reply-preview');
            const previewText = document.getElementById('reply-text');

            preview.style.display = 'block';

            // D√©termine le texte √† afficher dans l'aper√ßu selon le type
            if (msg.type === 'image') {
                previewText.textContent = "üì∑ Image";
            } else if (msg.type === 'voice') {
                previewText.textContent = "üé§ Message vocal";
            } else {
                previewText.textContent = msg.text || "Message";
            }

            document.getElementById('msg-input').focus();
        }
        window.closeAllMenus();
    };
    async function envoyerPush(targetPlayerId, titre, message) {
        const apiKey = "os_v2_app_xse37kmadzf5bilygfagjzcppxcke2r3rfoe2jfgdgtqlv72wfn6uwijbxl7rlpfnc4yodwbszlau6jggtk4iv4kfbssmx46p3h2xbi";
        const user = auth.currentUser;
        const myName = titre || localStorage.getItem('myme-user-name') || "Myme";

        try {
            await fetch("https://onesignal.com/api/v1/notifications", {
                method: "POST",
                headers: {
                    "Content-Type": "application/json; charset=utf-8",
                    "Authorization": "Basic " + apiKey
                },
                body: JSON.stringify({
                    app_id: "bc89bfa9-801e-4bd0-a178-314064e44f7d",
                    include_player_ids: [targetPlayerId],

                    // TITRE : Nom de l'envoyeur
                    headings: {"fr": myName},

                    // CONTENU : Le texte du message
                    contents: {"fr": message},

                    // PHOTO DE PROFIL : Appara√Æt √† c√¥t√© du message
                    large_icon: user.photoURL || `https://ui-avatars.com/api/?name=${user.displayName}`,

                    // LOGO APP : Couleur (Bleu Myme)
                    android_accent_color: "FF0866FF",

                    // GESTION DU BADGE (Chiffre sur l'ic√¥ne)
                    android_badge_type: "Increase", // Augmente le chiffre de 1 √† chaque message
                    android_badge_count: 1,

                    priority: 10
                })
            });
        } catch (e) {
            console.error("Push Error:", e);
        }
    }

    window.cancelReply = () => {
        replyingTo = null;
        document.getElementById('reply-preview').style.display = 'none';
    };
    // Fonction pour remettre le badge de l'ic√¥ne √† z√©ro
    async function resetAppBadge() {
        if (window.OneSignal) {
            try {
                // Efface les notifications visibles
                await OneSignal.Notifications.clearAll();
                // Force la remise √† z√©ro du chiffre sur l'ic√¥ne (badge)
                // Note: Selon la version du SDK, clearAll() peut suffire,
                // sinon on utilise les m√©thodes natives de Capacitor.
            } catch (e) {
                console.log("Erreur reset badge", e);
            }
        }
    }



    // --- 1. SUPPRESSION SYNCHRONIS√âE --- sendMessage
    window.deleteMessageSync = async () => {
        if (!selectedMsgId || !auth.currentUser) return;
        try {
            const chatId = auth.currentUser.uid < targetUid ? auth.currentUser.uid + "_" + targetUid : targetUid + "_" + auth.currentUser.uid;
            // Supprime directement dans Firebase (sera d√©tect√© par l'autre via onSnapshot)
            await deleteDoc(doc(db, "chats", chatId, "messages", selectedMsgId));
            window.closeAllMenus();
            window.showToast("data-lang", "Message-deleted");
        } catch (e) { window.showToast("data-lang", "suppression"); }
    };
    window.handleMsgActions = (e, msgId) => {
        selectedMsgId = msgId;
        const contextMenu = document.getElementById('custom-context-menu');
        contextMenu.style.display = 'block';
        contextMenu.style.left = e.pageX + 'px';
        contextMenu.style.top = e.pageY + 'px';

        // Fermer le menu si on clique ailleurs
        setTimeout(() => {
            document.addEventListener('click', () => {
                contextMenu.style.display = 'none';
            }, { once: true });
        }, 10);
    };
    function applyMymeGlobalStyles() {
        // --- Styles de base ---
        const fs = localStorage.getItem('myme-fsize') || '16px';
        const ff = localStorage.getItem('myme-ffam') || "'Segoe UI'";
        const rad = localStorage.getItem('myme-radius') || '20px';
        const gh = localStorage.getItem('myme-ghost') || '1';
        const theme = localStorage.getItem('theme');

        document.documentElement.style.setProperty('--app-font-size', fs);
        document.documentElement.style.setProperty('--app-font-family', ff);
        document.documentElement.style.setProperty('--app-radius', rad);
        document.body.style.opacity = gh;
        document.body.style.fontFamily = ff;

        // --- SYNCHRO FOND D'√âCRAN ---
        const specificWall = localStorage.getItem(`wallpaper_${targetUid}`);
        const globalWall = localStorage.getItem('myme-bg');
        const finalWall = specificWall || globalWall;

        const bgElement = document.getElementById('chat-bg');
        if (bgElement && finalWall) {
            bgElement.style.backgroundImage = `url(${finalWall})`;
        }
        if (theme === 'dark') {
            document.body.classList.add('dark-mode');
        } else {
            document.body.classList.remove('dark-mode');
        }

        // --- SYNCHRO OPACIT√â (LUMINOSIT√â) ---
        const savedOpacity = localStorage.getItem(`opacity_${targetUid}`) || "0";
        const overlay = document.getElementById('bg-overlay');
        const rangeInput = document.getElementById('lum-range');

        if (overlay) overlay.style.opacity = savedOpacity;
        if (rangeInput) rangeInput.value = savedOpacity; // Aligne le curseur sur la r√©alit√©
    }

        // Appeler la fonction au d√©marrage
    document.addEventListener('DOMContentLoaded', applyMymeGlobalStyles);
    window.changeBrightness = (v) => {
            const overlay = document.getElementById('bg-overlay');
            if (overlay) {
                overlay.style.opacity = v; // Change le noir en temps r√©el
            }
            localStorage.setItem(`opacity_${targetUid}`, v); // Sauvegarde pour ce chat pr√©cis
    };
    async function marquerMessagesCommeLus() {
        const history = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
        const myUid = auth.currentUser.uid;
        const chatId = myUid < targetUid ? `${myUid}_${targetUid}` : `${targetUid}_${myUid}`;

        // 1. Trouver les messages non lus venant de l'autre dans Firebase
        const q = query(
            collection(db, "chats", chatId, "messages"),
            where("senderId", "==", targetUid),
            where("read", "==", false)
        );

        try {
            const snap = await getDocs(q);
            if (snap.empty) return;

            // 2. Mettre √† jour Firebase
            const batch = [];
            snap.forEach(docSnap => {
                batch.push(updateDoc(docSnap.ref, { read: true }));
            });
            await Promise.all(batch);

            // 3. Mettre √† jour le LocalStorage pour l'affichage imm√©diat
            const nouvelleHistory = history.map(msg => {
                if (msg.senderId === targetUid) msg.read = true;
                return msg;
            });
            localStorage.setItem(STORAGE_KEY, JSON.stringify(nouvelleHistory));

        } catch (e) {
            console.error("Erreur synchro 'Lu':", e);
        }
    }

    window.changeWallpaper = (input) => {
        if (input.files && input.files[0]) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const base64 = e.target.result;
                document.getElementById('chat-bg').style.backgroundImage = `url(${base64})`;
                localStorage.setItem(`wallpaper_${targetUid}`, base64);
                window.handleToast("wallpaper-updated"); // Utilise ton nouveau handleToast
            };
            reader.readAsDataURL(input.files[0]);
        }
    };
    window.blockUser = async () => {
        if (!auth.currentUser || !targetUid) return;

        try {
            const userRef = doc(db, "users", auth.currentUser.uid);
            const userSnap = await getDoc(userRef);

            if (userSnap.exists()) {
                let blockedList = userSnap.data().blockedUsers || [];

                if (!blockedList.includes(targetUid)) {
                    blockedList.push(targetUid);
                    await updateDoc(userRef, { blockedUsers: blockedList });
                    window.handleToast("user-blocked"); // Utilise ton syst√®me de traduction

                    // Optionnel : Rediriger vers l'accueil apr√®s 2 secondes
                    setTimeout(() => window.location.href = "ACCEUIL.html", 2000);
                } else {
                    window.handleToast("already-blocked");
                }
            }
        } catch (e) {
            console.error(e);
            window.handleToast("error-action");
        }
    };
    window.unblockUser = async () => {
        if (!auth.currentUser || !targetUid) return;

        try {
            const userRef = doc(db, "users", auth.currentUser.uid);
            const userSnap = await getDoc(userRef);

            if (userSnap.exists()) {
                const blockedList = userSnap.data().blockedUsers || [];
                const updatedList = blockedList.filter(id => id !== targetUid);

                await updateDoc(userRef, { blockedUsers: updatedList });

                // Mise √† jour locale imm√©diate
                myBlockedList = updatedList;

                // On rafra√Æchit le bouton et on relance le rendu des messages
                updateBlockButton();
                const currentHistory = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
                renderMessages(currentHistory, auth.currentUser.uid);

                window.showToast("Contact d√©bloqu√© !");
            }
        } catch (e) {
            console.error("Erreur d√©blocage:", e);
            window.showToast("Erreur lors du d√©blocage");
        }
    };

    window.handleToast = async function(param) {
        const key = (typeof param === 'string') ? param : param.getAttribute("data-toast-lang");
        const lang = localStorage.getItem("lang") || "en";

    try {
            const res = await fetch("lang.json");
            const data = await res.json();
            const translatedMsg = (data[lang] && data[lang][key]) ? data[lang][key] : "Action effectu√©e";
            window.showToast(translatedMsg);
        } catch (error) {
            window.showToast("...");
        }
    };

        // --- 2. T√âL√âCHARGEMENT --- mediaRecorder
    window.downloadImage = async (base64Data) => {
        try {
            // V√©rifie si on est sur mobile ou sur PC
            const isNative = window.Capacitor && window.Capacitor.isNativePlatform();

            if (isNative) {
                // --- LOGIQUE T√âL√âPHONE (Android/iOS) ---
                const { Filesystem, Share } = Capacitor.Plugins;
                const fileName = `Myme_Image_${Date.now()}.jpg`;
                const base64Content = base64Data.includes(',') ? base64Data.split(',')[1] : base64Data;

                const result = await Filesystem.writeFile({
                    path: fileName,
                    data: base64Content,
                    directory: 'CACHE'
                });

                await Share.share({
                    title: "Enregistrer l'image",
                    url: result.uri
                });

            } else {
                // --- LOGIQUE PC WINDOWS (Navigateur/GitHub Pages) ---
                const fileName = `Myme_Image_${Date.now()}.jpg`;
            
                // On cr√©e un lien invisible pour forcer le t√©l√©chargement
                const link = document.createElement('a');
                link.href = base64Data;
                link.download = fileName;
            
                // On simule un clic
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            
                console.log("Image t√©l√©charg√©e sur le PC");
            }

        } catch (e) {
            console.error("Erreur :", e);
            if (window.showToast) window.showToast("Erreur lors de la sauvegarde");
        }
    };
    // 1. Mets la fonction updateBlockButton SEULE, en dehors des autres
    function updateBlockButton() {
        const btn = document.getElementById('block-action-btn');
        if (!btn) return;

        if (myBlockedList.includes(targetUid)) {
            btn.textContent = "D√©bloquer ce contact";
            btn.style.color = "#29bd49";
            btn.style.background = "#29bd4915";
            btn.onclick = window.unblockUser;
        } else {
            btn.textContent = "Bloquer ce contact";
            btn.style.color = "#ff4d4d";
            btn.style.background = "#ff4d4d15";
            btn.onclick = window.blockUser;
        }
    }

    // 2. Ta fonction loadTargetUserInfo simplifi√©e
    async function loadTargetUserInfo() {
        console.log("üîç Diagnostic lanc√© pour :", targetUid);

        // S√©curit√© : Si apr√®s 5 secondes rien ne se passe, on pr√©vient
        const timeout = setTimeout(() => {
            console.warn("‚ö†Ô∏è Firestore ne r√©pond toujours pas (Probl√®me de connexion ou de permissions ?)");
        }, 5000);

        const docRef = doc(db, "users", targetUid);

        onSnapshot(docRef, (snapshot) => {
            clearTimeout(timeout); // On annule l'alerte car √ßa r√©pond !
        
            console.log("‚úÖ R√©ponse re√ßue ! Existe ?", snapshot.exists());
        
            if (snapshot.exists()) {
                const data = snapshot.data();
                updateTargetUI(data);
                updateBlockButton();
            } else {
                console.error("‚ùå Erreur : L'UID n'existe pas dans la collection 'users'");
            }
        }, (error) => {
            clearTimeout(timeout);
            console.error("üî• ERREUR FIRESTORE :", error.code, error.message);
        });
    }
    // 1. Fonction pour mettre √† jour mon statut
    async function updateMyStatus(status) {
        const user = auth.currentUser;
        if (user) {
            const myDocRef = doc(db, "users", user.uid);
            try {
                await updateDoc(myDocRef, {
                    isOnline: status,
                    lastSeen: serverTimestamp() // Utile pour afficher "Vu pour la derni√®re fois le..."
                });
                console.log("Mon statut est maintenant :", status ? "En ligne" : "Hors ligne");
            } catch (e) {
                console.error("Erreur mise √† jour statut :", e);
            }
        }
    }

    // 2. D√©tecter la connexion / d√©connexion
    onAuthStateChanged(auth, (user) => {
        if (user) {
            // Je viens de me connecter ou j'ouvre l'appli
            updateMyStatus(true);
        }
    });

    // 3. D√©tecter quand l'utilisateur ferme l'onglet ou le navigateur
    window.addEventListener('beforeunload', () => {
        updateMyStatus(false);
    });

    // 4. (Optionnel) D√©tecter si l'utilisateur change d'onglet (√©conomie d'√©nergie)
    document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') {
            updateMyStatus(true);
        } else {
            updateMyStatus(false);
        }
    });
    // Fonction helper pour mettre √† jour l'interface
    function updateTargetUI(data) {
        console.log("Donn√©es re√ßues pour l'UI :", data);

        const fullName = data.prenom + " " + (data.nom || "");
        const photo = data.photoURL || `https://ui-avatars.com/api/?name=${data.prenom}`;

    // Fonction interne pour mettre √† jour un texte sans faire planter le script
        const safeText = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.textContent = value;
            else console.warn(`√âl√©ment introuvable : ${id}`);
        };

        // Fonction interne pour mettre √† jour une image
        const safeSrc = (id, value) => {
            const el = document.getElementById(id);
            if (el) el.src = value;
        };

        // Mise √† jour des infos de base
        safeText('target-name', fullName);
        safeSrc('target-avatar', photo);
        safeText('profile-name-full', fullName);
        safeSrc('profile-img-full', photo);
        safeText('profile-phone-full', data.telephone || "Non renseign√©");

        // Gestion de la pr√©sence
        const dot = document.getElementById('presence-dot');
        const text = document.getElementById('presence-text');

        if (dot && text) {
            // On v√©rifie si data.isOnline existe ET s'il est √©gal √† true
            if (data && data.isOnline === true) {
                dot.className = "status-dot online";
                text.textContent = "En ligne";
            } else {
                // Si c'est false, undefined ou null, on met Hors ligne
                dot.className = "status-dot offline";
                text.textContent = "Hors ligne";
            }
        }
    }

    // --- 3. RENDU DES MESSAGES (DATE & HEURE) ---
    function renderMessages(history, myUid) {
        if (isRendering) return;
        isRendering = true;
        const win = document.getElementById('chat-window');
        const fragment = document.createDocumentFragment();
        let lastDateLabel = "";

        history.forEach(m => {
            const isMe = m.senderId === myUid;

            // --- GESTION DU NOM POUR LES R√âPONSES ---
            let replyHTML = "";
            if (m.replyTo) {
                // On cherche le surnom de celui √† qui on r√©pond
                const rId = m.replyTo.senderId;
                const rNickname = localStorage.getItem(`nickname_${rId}`);
                const rName = (rId === myUid) ? "Moi" : (rNickname || "Contact");

                replyHTML = `
                    <div class="reply-quote" style="background:rgba(0,0,0,0.08); padding:8px; border-left:4px solid #0866ff; margin-bottom:8px; font-size:12px; border-radius:8px; color:#555;">
                        <b style="color:#0866ff; font-size:10px; display:block; margin-bottom:2px;">En r√©ponse √† ${rName}</b>
                        ${m.replyTo.text}
                    </div>`;
            }

            const dObj = m.createdAt && m.createdAt.seconds ? new Date(m.createdAt.seconds * 1000) : new Date();
            const timeStr = dObj.toLocaleTimeString('fr-FR', { hour:'2-digit', minute:'2-digit' });
            if (m.createdAt) {
                // Ensuite on g√®re le s√©parateur de date
                const dLabel = dObj.toLocaleDateString('fr-FR', { weekday: 'long', day: 'numeric', month: 'long' });
                if (dLabel !== lastDateLabel) {
                    const dDiv = document.createElement('div');
                    dDiv.className = "date-separator";
                    dDiv.style = "text-align:center; margin:15px 0; font-size:11px; color:#888; text-transform:capitalize;";
                    dDiv.textContent = dLabel;
                    fragment.appendChild(dDiv);
                    lastDateLabel = dLabel;
                }
            }

            let status = "";

            if (isMe) {
                if (!m.createdAt) {
                    // 1. Message pas encore sur le serveur (envoi en cours)
                    status = `<span style="color:#999; font-size:10px;">‚úî</span>`;
                } else if (m.read) {
                    // 2. Message lu par le destinataire
                    status = `<span style="color:#ff9500; font-weight:bold;">‚úî‚úî</span>`;
                } else {
                    // 3. Message arriv√© sur le serveur (mais pas lu)
                    status = `<span style="color:#999;">‚úî‚úî</span>`;
                }
            }
            let content = "";
            if (m.type === 'image') {
                 content = `<div class="msg-bubble img-bubble" style="position:relative;">
                    ${replyHTML}
                    <img src="${m.imageData}" style="border-radius:10px; max-width:200px; display:block;">
                    <div class="dl-btn" onclick="downloadImage('${m.imageData}')" style="position:absolute; bottom:5px; right:5px; background:rgba(0,0,0,0.5); color:white; border-radius:50%; width:24px; height:24px; display:flex; align-items:center; justify-content:center; cursor:pointer; font-size:10px;">‚¨á</div>
                </div>`;
                updateGallery(m.imageData);
            } else if (m.type === 'voice') {
                content = `<div class="vocal-bubble">${replyHTML}<button onclick="playVoice('${m.id}', this)">‚ñ∂</button><audio id="aud_${m.id}" src="${m.audioData}"></audio></div>`;
            } else {
                // Pour le texte simple
                content = `<div class="msg-bubble">${replyHTML}${m.text || ""}</div>`;
            }
            const msgDiv = document.createElement('div');
            msgDiv.className = `msg-wrapper ${isMe ? 'me' : 'them'}`;


            msgDiv.oncontextmenu = (e) => {
                if (m.isTemp || !m.id || m.id.startsWith('temp_')) {
                    console.log("Suppression impossible : message en cours d'envoi...");
                    return;
                }
                e.preventDefault();
                selectedMsgId = m.id;
                const menu = document.getElementById('custom-context-menu');
                if (menu) {
                    menu.style.display = 'block';
                    menu.style.left = e.pageX + 'px';
                    menu.style.top = e.pageY + 'px';
                }
            };

            msgDiv.innerHTML = `${content}<div class="msg-info" style="font-size:10px; color:#888; margin-top:2px;">${timeStr} ${status}</div>`;
            fragment.appendChild(msgDiv);
        });
        win.innerHTML = ""; win.appendChild(fragment);
        win.scrollTo(0, win.scrollHeight);
        isRendering = false;
    }

    // --- 4. √âCOUTE FIREBASE SYNCHRONIS√âE (CORRIG√â) ---
    onAuthStateChanged(auth, async (user) => {
    if (!user || !targetUid) return;
    isRendering = false;

    // 1. CHARGEMENT INITIAL (Cache & UI)
    const saved = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
    if (saved.length > 0) renderMessages(saved, user.uid);

    loadTargetUserInfo();
    resetAppBadge();

    const chatId = auth.currentUser.uid < targetUid ? auth.currentUser.uid + "_" + targetUid : targetUid + "_" + auth.currentUser.uid;

    // 2. R√âCUP√âRATION BLOCAGE
    try {
        const userDoc = await getDoc(doc(db, "users", user.uid));
        myBlockedList = userDoc.data()?.blockedUsers || [];
        updateBlockButton();
    } catch(e) { console.log("Mode Offline"); }

    // 3. √âCOUTEUR TYPING (Optimis√© pour ne pas tout recharger)
    const contactTypingRef = doc(db, "chats", chatId, "typingStatus", targetUid);
    onSnapshot(contactTypingRef, (docSnap) => {
        const presenceText = document.getElementById('presence-text');
        if (!presenceText) return;

        if (docSnap.exists() && docSnap.data().isTyping) {
            presenceText.textContent = "√âcrit...";
            presenceText.style.color = "#29bd49";
        } else {
            // On remet le texte du cache sans relancer loadTargetUserInfo
            const cached = JSON.parse(localStorage.getItem(`cache_user_${targetUid}`));
            presenceText.textContent = cached?.isOnline ? "En ligne" : "Hors ligne";
            presenceText.style.color = "#888";
        }
    });

    // 4. √âCOUTEUR MESSAGES (Correction de la disparition des photos)
    const msgCol = collection(db, "chats", chatId, "messages");
    onSnapshot(query(msgCol, orderBy("createdAt", "asc")), (snap) => {
            let history = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
            let hasChange = false;

            snap.docChanges().forEach(change => {
                const m = change.doc.data();
                const id = change.doc.id;

                if (change.type === "added") {
                    // On cherche si un message avec le m√™me contenu existe d√©j√† (version temp)
                    const isDuplicate = history.find(x =>
                        (x.id === id) ||
                        (x.isTemp && x.imageData === m.imageData && x.senderId === m.senderId)
                    );

                    if (!isDuplicate && !myBlockedList.includes(m.senderId)) {
                        // Si on trouve un message temporaire qui correspond, on le remplace par le vrai
                        const tempIndex = history.findIndex(x => x.isTemp && x.imageData === m.imageData);
                        if (tempIndex !== -1) {
                            history[tempIndex] = { id, ...m }; // On remplace le temporaire par le d√©finitif
                        } else {
                            history.push({ id, ...m }); // Sinon on ajoute normalement
                        }
                        hasChange = true;
                    }
                }
                if (change.type === "modified") {
                    // IMPORTANT pour les coches (statut LU)
                    const index = history.findIndex(x => x.id === id);
                    if (index !== -1) {
                        history[index] = { id, ...m };
                        hasChange = true;
                    }
                }
                if (change.type === "removed") {
                    history = history.filter(x => x.id !== id);
                    hasChange = true;
                }
            });

            if (hasChange) {
                // Tri stable pour Python-style : garde les messages sans date √† la fin
                history.sort((a, b) => {
                    const timeA = a.createdAt?.seconds || Date.now() / 1000;
                    const timeB = b.createdAt?.seconds || Date.now() / 1000;
                    return timeA - timeB;
                });

                localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
                renderMessages(history, user.uid);
                marquerMessagesCommeLus();
            }
        });
    });


    function updateGallery(imgSrc) {
        const grid = document.getElementById('profile-media-grid');
        const emptyMsg = grid.querySelector('.empty-gallery');
        if (emptyMsg) emptyMsg.remove();

        // V√©rifie si l'image est d√©j√† affich√©e pour √©viter les doublons
        if (grid.querySelector(`img[src="${imgSrc}"]`)) return;

        const div = document.createElement('div');
        div.className = 'media-item';
        div.innerHTML = `<img src="${imgSrc}" onclick="window.downloadImage('${imgSrc}')">`;
        grid.prepend(div); // Ajoute la plus r√©cente en premier

        // Met √† jour le compteur
        const count = grid.querySelectorAll('.media-item').length;
        document.getElementById('media-count-badge').textContent = `${count} m√©dia(s)`;
    }
    window.sendImage = async (input) => {
        const file = input.files[0];
        if (!file || !auth.currentUser) return;

        const reader = new FileReader();
        reader.onload = async (e) => {
            const imageData = e.target.result;
            const myUid = auth.currentUser.uid;

            // 1. Pr√©paration du message local (Instantan√©)
            let history = JSON.parse(localStorage.getItem(STORAGE_KEY) || "[]");
            const tempId = "temp_" + Date.now();
            const tempMsg = {
                id: tempId,
                type: 'image',
                imageData: imageData,
                senderId: myUid,
                createdAt: { seconds: Math.floor(Date.now() / 1000) },
                read: false,
                isTemp: true,
                replyTo: replyingTo ? { ...replyingTo } : null
            };

            history.push(tempMsg);
            localStorage.setItem(STORAGE_KEY, JSON.stringify(history));
            renderMessages(history, myUid);

            // 2. Nettoyage de l'interface de r√©ponse
            const replyData = replyingTo ? { text: replyingTo.text, id: replyingTo.id } : null;
            cancelReply();

            try {
                const chatId = myUid < targetUid ? `${myUid}_${targetUid}` : `${targetUid}_${myUid}`;

                // 3. Envoi √† Firestore
                await addDoc(collection(db, "chats", chatId, "messages"), {
                    senderId: myUid,
                    receiverId: targetUid,
                    type: 'image',
                    imageData: imageData, // En Base64 comme tu as fait
                    replyTo: replyData,
                    createdAt: serverTimestamp(),
                    read: false
                });

                // 4. Notification Push
                const receiverSnap = await getDoc(doc(db, "users", targetUid));
                if (receiverSnap.exists() && receiverSnap.data().oneSignalPlayerId) {
                    envoyerPush(receiverSnap.data().oneSignalPlayerId,
                            localStorage.getItem('myme-user-name') || "Myme",
                            "üì∑ Image");
                }

                input.value = ""; // Reset l'input
            } catch (err) {
                console.error("Erreur envoi image:", err);
                window.showToast("Erreur d'envoi");
            }
        };
        reader.readAsDataURL(file);
    };
    window.addEventListener('beforeunload', () => {
        if (auth.currentUser && targetUid) {
            const chatId = auth.currentUser.uid < targetUid ? auth.currentUser.uid + "_" + targetUid : targetUid + "_" + auth.currentUser.uid;
            const myTypingRef = doc(db, "chats", chatId, "typingStatus", auth.currentUser.uid);
            setDoc(myTypingRef, { isTyping: false }, { merge: true });
        }
    });

    // --- 5. ENVOI & UI ---
    window.sendMessage = async () => {
        if (myBlockedList.includes(targetUid)) {
            window.showToast("data-lang", "Debloqued");
            return;
        }
        const inp = document.getElementById('msg-input');
        if (!inp.value.trim() || !auth.currentUser) return;

        const val = inp.value.trim();
        const myUid = auth.currentUser.uid;
        clearBadgeOnEntry();
        inp.value = "";
        toggleIcon(false);
        const replyData = replyingTo ? { text: replyingTo.text, id: replyingTo.id } : null;
        cancelReply();
        // --- NOTIFICATION ---
        try {
            const receiverSnap = await getDoc(doc(db, "users", targetUid));
            const receiverData = receiverSnap.data();
            const myName = localStorage.getItem('myme-user-name') || "Myme";

            if (receiverData && receiverData.oneSignalPlayerId) {
                envoyerPush(
                    receiverData.oneSignalPlayerId,
                    myName,
                    val // Le texte du message
                );
            }
        } catch (e) { console.log("Erreur Push:", e); }

        // --- ENVOI FIREBASE ---
        const sound = document.getElementById('send-sound');
        if (sound) { sound.currentTime = 0; sound.play().catch(() => {}); }

        try {
            const chatId = auth.currentUser.uid < targetUid ? auth.currentUser.uid + "_" + targetUid : targetUid + "_" + auth.currentUser.uid;
            const monRef = doc(db, "users", myUid);
            const sonRef = doc(db, "users", targetUid);

            // Utilise arrayUnion pour √©viter les doublons
            await updateDoc(monRef, { contactList: arrayUnion(targetUid) });
            await updateDoc(sonRef, { contactList: arrayUnion(auth.currentUser.uid) });

            await addDoc(collection(db, "chats", chatId, "messages"), {
                text: val,
                senderId: myUid,
                receiverId: targetUid,
                type: 'text',
                replyTo: replyData,
                createdAt: serverTimestamp(),
                read: false
            });
            await updateContactsAfterMessage(myUid, targetUid);
        } catch (e) { console.error(e); }

    };
    async function updateContactsAfterMessage(myUid, targetUid) {
        const myRef = doc(db, "users", myUid);
        const theirRef = doc(db, "users", targetUid);

        // 1. Ajouter l'autre √† ma liste
        const myDoc = await getDoc(myRef);
        let myContacts = myDoc.data()?.contactList || [];

        // Correction ici : targetUid au lieu de theirUid
        if (!myContacts.includes(targetUid)) {
            myContacts.push(targetUid);
            await updateDoc(myRef, { contactList: myContacts });
        }

        // 2. Ajouter MOI √† la liste de l'autre
        const theirDoc = await getDoc(theirRef);
        let theirContacts = theirDoc.data()?.contactList || [];
        if (!theirContacts.includes(myUid)) {
            theirContacts.push(myUid);
            await updateDoc(theirRef, { contactList: theirContacts });
        }
    }
    window.clearFullChat = () => {
        document.getElementById('confirm-modal').style.display = 'flex';
        window.toggleMenu(); // Ferme le menu de discussion
    };

    window.closeConfirmModal = () => {
        document.getElementById('confirm-modal').style.display = 'none';
    };


    function updateRecordUI(active) {
        const voiceBtn = document.getElementById('voice-btn');
        const msgInput = document.getElementById('msg-input');
        const recLabel = document.getElementById('recording-label');

        voiceBtn.classList.toggle('recording', active);
        msgInput.style.display = active ? 'none' : 'block';
        recLabel.style.display = active ? 'block' : 'none';

        if (active) {
            let seconds = 0;
            recLabel.textContent = "00:00";
            recInterval = setInterval(() => {
                seconds++;
                recLabel.textContent = `00:${seconds.toString().padStart(2, '0')}`;
            }, 1000);
        } else {
            clearInterval(recInterval);
            recLabel.textContent = "00:00";
        }
    }

    window.executeClearChat = async () => {
        try {
            const chatId = auth.currentUser.uid < targetUid ? auth.currentUser.uid + "_" + targetUid : targetUid + "_" + auth.currentUser.uid;
            const msgCol = collection(db, "chats", chatId, "messages");
            const snap = await getDocs(msgCol);
            document.getElementById('profile-media-grid').innerHTML = '<div class="empty-gallery">Aucun m√©dia partag√©.</div>';

            // Supprime chaque message un par un sur Firebase
            const promises = snap.docs.map(d => deleteDoc(d.ref));
            await Promise.all(promises);

            // Vide aussi le local
            localStorage.removeItem(STORAGE_KEY);

            window.closeConfirmModal();
            window.showToast("Discussion vid√©e");
        } catch (e) {
            window.showToast("Erreur lors du nettoyage");
        }
    };

    window.toggleMenu = (e) => { if(e) e.stopPropagation(); const m = document.getElementById('chat-menu'); m.style.display = (m.style.display === 'flex') ? 'none' : 'flex'; };
    window.showProfile = (e) => { if(e) e.stopPropagation(); document.getElementById('contact-profile').style.display = 'flex'; };
    window.hideProfile = () => { document.getElementById('contact-profile').style.display = 'none'; };
    window.closeAllMenus = () => { document.getElementById('chat-menu').style.display = 'none'; document.getElementById('custom-context-menu').style.display = 'none'; };
    window.showToast = async (msgOrType, key) => {
        const t = document.getElementById('toast');
        if (!t) return;

        let finalMsg = msgOrType;

        // Si on appelle showToast("data-lang", "une-cle")
        if (msgOrType === "data-lang" && key) {
            const lang = localStorage.getItem("lang") || "fr";
            try {
                const res = await fetch("lang.json");
                const data = await res.json();
                // On cherche la traduction, sinon on affiche la cl√© par d√©faut
                finalMsg = (data[lang] && data[lang][key]) ? data[lang][key] : key;
            } catch (e) {
                finalMsg = key;
            }
        }

        t.textContent = finalMsg;
        t.style.display = 'block';
        setTimeout(() => { t.style.display = 'none'; }, 3000);
    };

    function toggleIcon(hasText) { document.getElementById('send-btn').style.display = hasText ? 'block' : 'none'; document.getElementById('voice-btn').style.display = hasText ? 'none' : 'block'; }
    document.getElementById('msg-input').oninput = (e) => toggleIcon(e.target.value.trim().length > 0);
    document.addEventListener('click', window.closeAllMenus);
    let mediaRecorder;
    let audioChunks = [];

    const voiceBtn = document.getElementById('voice-btn');
    const recordLabel = document.getElementById('recording-label');
    const msgInput = document.getElementById('msg-input');

    voiceBtn.onpointerdown = async (e) => {
        // Emp√™che le scroll pendant qu'on reste appuy√©
        if (e.cancelable) e.preventDefault();

        try {
            // Demande explicite du flux
            mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });

            // Android pr√©f√®re souvent 'audio/webm;codecs=opus'
            const options = { mimeType: 'audio/webm' };
            mediaRecorder = new MediaRecorder(mediaStream, options);
            audioChunks = [];

            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) audioChunks.push(event.data);
            };

            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                const reader = new FileReader();
                reader.readAsDataURL(audioBlob);
                reader.onloadend = async () => {
                    const base64Audio = reader.result;

                    // --- 1. D√©finir le nom de l'envoyeur ---
                    const myName = localStorage.getItem('myme-user-name') || "Myme";

                    // --- 2. Notification Push ---
                    try {
                        const receiverSnap = await getDoc(doc(db, "users", targetUid));
                        const receiverData = receiverSnap.data();
                        if (receiverData?.oneSignalPlayerId) {
                            envoyerPush(receiverData.oneSignalPlayerId, myName, "üé§ Message vocal");
                        }
                    } catch (e) { console.log("Erreur Push Vocal:", e); }

                    // --- 3. Pr√©paration de la citation (Reply) ---
                    // On v√©rifie si replyingTo existe, sinon on met null
                    const replyData = replyingTo ? {
                        id: replyingTo.id,
                        // On utilise le texte d√©j√† pr√©par√© par prepareReply ou une valeur par d√©faut
                        text: replyingTo.text || "üé§ Message vocal"
                    } : null;

                    // Ferme l'aper√ßu imm√©diatement pour l'UI
                    cancelReply();

                    // --- 4. Envoi √† Firebase ---
                    try {
                        const chatId = auth.currentUser.uid < targetUid ? auth.currentUser.uid + "_" + targetUid : targetUid + "_" + auth.currentUser.uid;
                        await addDoc(collection(db, "chats", chatId, "messages"), {
                            senderId: auth.currentUser.uid,
                            receiverId: targetUid,
                            type: 'voice',
                            audioData: base64Audio,
                            replyTo: replyData,
                            createdAt: serverTimestamp(),
                            read: false
                        });
                    } catch (err) {
                        console.error("Erreur envoi vocal:", err);
                    }
                };

                // Arr√™t propre du micro
                if (mediaStream) {
                    mediaStream.getTracks().forEach(track => track.stop());
                }
            };

            mediaRecorder.start();
            updateRecordUI(true);
            if (window.navigator.vibrate) window.navigator.vibrate(50); // Petit retour haptique
        } catch (err) {
            console.error("Erreur Micro:", err);
            window.showToast("Micro non autoris√© ou non support√©");
        }
    };

    voiceBtn.onpointerup = () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
            updateRecordUI(false);
        }
    };
    voiceBtn.onpointerleave = () => {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
            updateRecordUI(false);
        }
    };

    // Fonction pour lire les vocaux (appel√©e dans le rendu des messages)
    window.playVoice = (id, btn) => {
        const audio = document.getElementById(`aud_${id}`);
        if (audio.paused) {
            audio.play();
            btn.textContent = "‚è∏";
            audio.onended = () => btn.textContent = "‚ñ∂";
        } else {
            audio.pause();
            btn.textContent = "‚ñ∂";
        }
    };

    // --- GESTION DE L'√âTAT "√âCRIT..." (√âMISSION) ---

    let isCurrentlyTypingInFirebase = false; // Flag local

    document.getElementById('msg-input').addEventListener('input', (e) => {
        toggleIcon(e.target.value.trim().length > 0);

        if (!auth.currentUser || !targetUid) return;
        const chatId = auth.currentUser.uid < targetUid ? auth.currentUser.uid + "_" + targetUid : targetUid + "_" + auth.currentUser.uid;
        const myTypingRef = doc(db, "chats", chatId, "typingStatus", auth.currentUser.uid);

        // On n'√©crit dans Firebase que si le statut change
        if (!isCurrentlyTypingInFirebase) {
            isCurrentlyTypingInFirebase = true;
            setDoc(myTypingRef, { isTyping: true }, { merge: true });
        }

        clearTimeout(typingTimeout);
        typingTimeout = setTimeout(() => {
            isCurrentlyTypingInFirebase = false;
            setDoc(myTypingRef, { isTyping: false }, { merge: true });
        }, 2000);
    });
</script>
</body>

</html>












